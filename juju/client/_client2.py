# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client.facade import Type, JSONObject
from juju.client._definitions import *


class AnnotationsFacade(Type):
    name = 'Annotations'
    version = 2
    schema = {
        'definitions': {
            'AnnotationsGetResult': {
                'additionalProperties': False,
                'properties': {
                    'annotations': {
                        'patternProperties': {'.*': {'type': 'string'}},
                        'type': 'object',
                    },
                    'entity': {'type': 'string'},
                    'error': {'$ref': '#/definitions/ErrorResult'},
                },
                'required': ['entity', 'annotations'],
                'type': 'object',
            },
            'AnnotationsGetResults': {
                'additionalProperties': False,
                'properties': {
                    'results': {
                        'items': {'$ref': '#/definitions/AnnotationsGetResult'},
                        'type': 'array',
                    }
                },
                'required': ['results'],
                'type': 'object',
            },
            'AnnotationsSet': {
                'additionalProperties': False,
                'properties': {
                    'annotations': {
                        'items': {'$ref': '#/definitions/EntityAnnotations'},
                        'type': 'array',
                    }
                },
                'required': ['annotations'],
                'type': 'object',
            },
            'Entities': {
                'additionalProperties': False,
                'properties': {
                    'entities': {
                        'items': {'$ref': '#/definitions/Entity'},
                        'type': 'array',
                    }
                },
                'required': ['entities'],
                'type': 'object',
            },
            'Entity': {
                'additionalProperties': False,
                'properties': {'tag': {'type': 'string'}},
                'required': ['tag'],
                'type': 'object',
            },
            'EntityAnnotations': {
                'additionalProperties': False,
                'properties': {
                    'annotations': {
                        'patternProperties': {'.*': {'type': 'string'}},
                        'type': 'object',
                    },
                    'entity': {'type': 'string'},
                },
                'required': ['entity', 'annotations'],
                'type': 'object',
            },
            'Error': {
                'additionalProperties': False,
                'properties': {
                    'code': {'type': 'string'},
                    'info': {
                        'patternProperties': {
                            '.*': {'additionalProperties': True, 'type': 'object'}
                        },
                        'type': 'object',
                    },
                    'message': {'type': 'string'},
                },
                'required': ['message', 'code'],
                'type': 'object',
            },
            'ErrorResult': {
                'additionalProperties': False,
                'properties': {'error': {'$ref': '#/definitions/Error'}},
                'type': 'object',
            },
            'ErrorResults': {
                'additionalProperties': False,
                'properties': {
                    'results': {
                        'items': {'$ref': '#/definitions/ErrorResult'},
                        'type': 'array',
                    }
                },
                'required': ['results'],
                'type': 'object',
            },
        },
        'properties': {
            'Get': {
                'description': 'Get returns annotations for given '
                'entities.\n'
                'If annotations cannot be retrieved for '
                'a given entity, an error is returned.\n'
                'Each entity is treated independently '
                'and, hence, will fail or succeed '
                'independently.',
                'properties': {
                    'Params': {'$ref': '#/definitions/Entities'},
                    'Result': {'$ref': '#/definitions/AnnotationsGetResults'},
                },
                'type': 'object',
            },
            'Set': {
                'description': 'Set stores annotations for given ' 'entities',
                'properties': {
                    'Params': {'$ref': '#/definitions/AnnotationsSet'},
                    'Result': {'$ref': '#/definitions/ErrorResults'},
                },
                'type': 'object',
            },
        },
        'type': 'object',
    }

    async def Get(self, entities=None) -> AnnotationsGetResults:
        """
        Get returns annotations for given entities.
        If annotations cannot be retrieved for a given entity, an error is returned.
        Each entity is treated independently and, hence, will fail or succeed independently.

        entities : typing.Sequence[~Entity]
        Returns -> AnnotationsGetResults
        """
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise TypeError(
                f'Expected entities to be a Sequence, received: {type(entities)}'
            )

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'Annotations',
            'request': 'Get',
            'version': 2,
            'params': _params,
        }
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return AnnotationsGetResults.from_json(reply['response'])

    async def Set(self, annotations=None) -> ErrorResults:
        """
        Set stores annotations for given entities

        annotations : typing.Sequence[~EntityAnnotations]
        Returns -> ErrorResults
        """
        if annotations is not None and not isinstance(annotations, (bytes, str, list)):
            raise TypeError(
                f'Expected annotations to be a Sequence, received: {type(annotations)}'
            )

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'Annotations',
            'request': 'Set',
            'version': 2,
            'params': _params,
        }
        _params['annotations'] = annotations
        reply = await self.rpc(msg)
        return ErrorResults.from_json(reply['response'])


class BlockFacade(Type):
    name = 'Block'
    version = 2
    schema = {
        'definitions': {
            'Block': {
                'additionalProperties': False,
                'properties': {
                    'id': {'type': 'string'},
                    'message': {'type': 'string'},
                    'tag': {'type': 'string'},
                    'type': {'type': 'string'},
                },
                'required': ['id', 'tag', 'type'],
                'type': 'object',
            },
            'BlockResult': {
                'additionalProperties': False,
                'properties': {
                    'error': {'$ref': '#/definitions/Error'},
                    'result': {'$ref': '#/definitions/Block'},
                },
                'required': ['result'],
                'type': 'object',
            },
            'BlockResults': {
                'additionalProperties': False,
                'properties': {
                    'results': {
                        'items': {'$ref': '#/definitions/BlockResult'},
                        'type': 'array',
                    }
                },
                'type': 'object',
            },
            'BlockSwitchParams': {
                'additionalProperties': False,
                'properties': {
                    'message': {'type': 'string'},
                    'type': {'type': 'string'},
                },
                'required': ['type'],
                'type': 'object',
            },
            'Error': {
                'additionalProperties': False,
                'properties': {
                    'code': {'type': 'string'},
                    'info': {
                        'patternProperties': {
                            '.*': {'additionalProperties': True, 'type': 'object'}
                        },
                        'type': 'object',
                    },
                    'message': {'type': 'string'},
                },
                'required': ['message', 'code'],
                'type': 'object',
            },
            'ErrorResult': {
                'additionalProperties': False,
                'properties': {'error': {'$ref': '#/definitions/Error'}},
                'type': 'object',
            },
        },
        'properties': {
            'List': {
                'description': 'List implements Block.List().',
                'properties': {'Result': {'$ref': '#/definitions/BlockResults'}},
                'type': 'object',
            },
            'SwitchBlockOff': {
                'description': 'SwitchBlockOff implements ' 'Block.SwitchBlockOff().',
                'properties': {
                    'Params': {'$ref': '#/definitions/BlockSwitchParams'},
                    'Result': {'$ref': '#/definitions/ErrorResult'},
                },
                'type': 'object',
            },
            'SwitchBlockOn': {
                'description': 'SwitchBlockOn implements ' 'Block.SwitchBlockOn().',
                'properties': {
                    'Params': {'$ref': '#/definitions/BlockSwitchParams'},
                    'Result': {'$ref': '#/definitions/ErrorResult'},
                },
                'type': 'object',
            },
        },
        'type': 'object',
    }

    async def List(self) -> BlockResults:
        """
        List implements Block.List().


        Returns -> BlockResults
        """

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'Block',
            'request': 'List',
            'version': 2,
            'params': _params,
        }

        reply = await self.rpc(msg)
        return BlockResults.from_json(reply['response'])

    async def SwitchBlockOff(self, message=None, type_=None) -> ErrorResult:
        """
        SwitchBlockOff implements Block.SwitchBlockOff().

        message : str
        type_ : str
        Returns -> ErrorResult
        """
        if message is not None and not isinstance(message, (bytes, str)):
            raise TypeError(f'Expected message to be a str, received: {type(message)}')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise TypeError(f'Expected type_ to be a str, received: {type(type_)}')

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'Block',
            'request': 'SwitchBlockOff',
            'version': 2,
            'params': _params,
        }
        _params['message'] = message
        _params['type'] = type_
        reply = await self.rpc(msg)
        return ErrorResult.from_json(reply['response'])

    async def SwitchBlockOn(self, message=None, type_=None) -> ErrorResult:
        """
        SwitchBlockOn implements Block.SwitchBlockOn().

        message : str
        type_ : str
        Returns -> ErrorResult
        """
        if message is not None and not isinstance(message, (bytes, str)):
            raise TypeError(f'Expected message to be a str, received: {type(message)}')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise TypeError(f'Expected type_ to be a str, received: {type(type_)}')

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'Block',
            'request': 'SwitchBlockOn',
            'version': 2,
            'params': _params,
        }
        _params['message'] = message
        _params['type'] = type_
        reply = await self.rpc(msg)
        return ErrorResult.from_json(reply['response'])


class HighAvailabilityFacade(Type):
    name = 'HighAvailability'
    version = 2
    schema = {
        'definitions': {
            'ControllersChangeResult': {
                'additionalProperties': False,
                'properties': {
                    'error': {'$ref': '#/definitions/Error'},
                    'result': {'$ref': '#/definitions/ControllersChanges'},
                },
                'required': ['result'],
                'type': 'object',
            },
            'ControllersChangeResults': {
                'additionalProperties': False,
                'properties': {
                    'results': {
                        'items': {'$ref': '#/definitions/ControllersChangeResult'},
                        'type': 'array',
                    }
                },
                'required': ['results'],
                'type': 'object',
            },
            'ControllersChanges': {
                'additionalProperties': False,
                'properties': {
                    'added': {'items': {'type': 'string'}, 'type': 'array'},
                    'converted': {'items': {'type': 'string'}, 'type': 'array'},
                    'maintained': {'items': {'type': 'string'}, 'type': 'array'},
                    'removed': {'items': {'type': 'string'}, 'type': 'array'},
                },
                'type': 'object',
            },
            'ControllersSpec': {
                'additionalProperties': False,
                'properties': {
                    'constraints': {'$ref': '#/definitions/Value'},
                    'num-controllers': {'type': 'integer'},
                    'placement': {'items': {'type': 'string'}, 'type': 'array'},
                },
                'required': ['num-controllers'],
                'type': 'object',
            },
            'ControllersSpecs': {
                'additionalProperties': False,
                'properties': {
                    'specs': {
                        'items': {'$ref': '#/definitions/ControllersSpec'},
                        'type': 'array',
                    }
                },
                'required': ['specs'],
                'type': 'object',
            },
            'Error': {
                'additionalProperties': False,
                'properties': {
                    'code': {'type': 'string'},
                    'info': {
                        'patternProperties': {
                            '.*': {'additionalProperties': True, 'type': 'object'}
                        },
                        'type': 'object',
                    },
                    'message': {'type': 'string'},
                },
                'required': ['message', 'code'],
                'type': 'object',
            },
            'Value': {
                'additionalProperties': False,
                'properties': {
                    'allocate-public-ip': {'type': 'boolean'},
                    'arch': {'type': 'string'},
                    'container': {'type': 'string'},
                    'cores': {'type': 'integer'},
                    'cpu-power': {'type': 'integer'},
                    'image-id': {'type': 'string'},
                    'instance-role': {'type': 'string'},
                    'instance-type': {'type': 'string'},
                    'mem': {'type': 'integer'},
                    'root-disk': {'type': 'integer'},
                    'root-disk-source': {'type': 'string'},
                    'spaces': {'items': {'type': 'string'}, 'type': 'array'},
                    'tags': {'items': {'type': 'string'}, 'type': 'array'},
                    'virt-type': {'type': 'string'},
                    'zones': {'items': {'type': 'string'}, 'type': 'array'},
                },
                'type': 'object',
            },
        },
        'properties': {
            'EnableHA': {
                'description': 'EnableHA adds controller machines '
                'as necessary to ensure the\n'
                'controller has the number of '
                'machines specified.',
                'properties': {
                    'Params': {'$ref': '#/definitions/ControllersSpecs'},
                    'Result': {'$ref': '#/definitions/ControllersChangeResults'},
                },
                'type': 'object',
            }
        },
        'type': 'object',
    }

    async def EnableHA(self, specs=None) -> ControllersChangeResults:
        """
        EnableHA adds controller machines as necessary to ensure the
        controller has the number of machines specified.

        specs : typing.Sequence[~ControllersSpec]
        Returns -> ControllersChangeResults
        """
        if specs is not None and not isinstance(specs, (bytes, str, list)):
            raise TypeError(f'Expected specs to be a Sequence, received: {type(specs)}')

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'HighAvailability',
            'request': 'EnableHA',
            'version': 2,
            'params': _params,
        }
        _params['specs'] = specs
        reply = await self.rpc(msg)
        return ControllersChangeResults.from_json(reply['response'])


class MetricsDebugFacade(Type):
    name = 'MetricsDebug'
    version = 2
    schema = {
        'definitions': {
            'Entities': {
                'additionalProperties': False,
                'properties': {
                    'entities': {
                        'items': {'$ref': '#/definitions/Entity'},
                        'type': 'array',
                    }
                },
                'required': ['entities'],
                'type': 'object',
            },
            'Entity': {
                'additionalProperties': False,
                'properties': {'tag': {'type': 'string'}},
                'required': ['tag'],
                'type': 'object',
            },
            'EntityMetrics': {
                'additionalProperties': False,
                'properties': {
                    'error': {'$ref': '#/definitions/Error'},
                    'metrics': {
                        'items': {'$ref': '#/definitions/MetricResult'},
                        'type': 'array',
                    },
                },
                'type': 'object',
            },
            'Error': {
                'additionalProperties': False,
                'properties': {
                    'code': {'type': 'string'},
                    'info': {
                        'patternProperties': {
                            '.*': {'additionalProperties': True, 'type': 'object'}
                        },
                        'type': 'object',
                    },
                    'message': {'type': 'string'},
                },
                'required': ['message', 'code'],
                'type': 'object',
            },
            'ErrorResult': {
                'additionalProperties': False,
                'properties': {'error': {'$ref': '#/definitions/Error'}},
                'type': 'object',
            },
            'ErrorResults': {
                'additionalProperties': False,
                'properties': {
                    'results': {
                        'items': {'$ref': '#/definitions/ErrorResult'},
                        'type': 'array',
                    }
                },
                'required': ['results'],
                'type': 'object',
            },
            'MeterStatusParam': {
                'additionalProperties': False,
                'properties': {
                    'code': {'type': 'string'},
                    'info': {'type': 'string'},
                    'tag': {'type': 'string'},
                },
                'required': ['tag', 'code'],
                'type': 'object',
            },
            'MeterStatusParams': {
                'additionalProperties': False,
                'properties': {
                    'statues': {
                        'items': {'$ref': '#/definitions/MeterStatusParam'},
                        'type': 'array',
                    }
                },
                'required': ['statues'],
                'type': 'object',
            },
            'MetricResult': {
                'additionalProperties': False,
                'properties': {
                    'key': {'type': 'string'},
                    'labels': {
                        'patternProperties': {'.*': {'type': 'string'}},
                        'type': 'object',
                    },
                    'time': {'format': 'date-time', 'type': 'string'},
                    'unit': {'type': 'string'},
                    'value': {'type': 'string'},
                },
                'required': ['time', 'key', 'value', 'unit', 'labels'],
                'type': 'object',
            },
            'MetricResults': {
                'additionalProperties': False,
                'properties': {
                    'results': {
                        'items': {'$ref': '#/definitions/EntityMetrics'},
                        'type': 'array',
                    }
                },
                'required': ['results'],
                'type': 'object',
            },
        },
        'properties': {
            'GetMetrics': {
                'description': 'GetMetrics returns all metrics '
                'stored by the state server.',
                'properties': {
                    'Params': {'$ref': '#/definitions/Entities'},
                    'Result': {'$ref': '#/definitions/MetricResults'},
                },
                'type': 'object',
            },
            'SetMeterStatus': {
                'description': 'SetMeterStatus sets meter ' 'statuses for entities.',
                'properties': {
                    'Params': {'$ref': '#/definitions/MeterStatusParams'},
                    'Result': {'$ref': '#/definitions/ErrorResults'},
                },
                'type': 'object',
            },
        },
        'type': 'object',
    }

    async def GetMetrics(self, entities=None) -> MetricResults:
        """
        GetMetrics returns all metrics stored by the state server.

        entities : typing.Sequence[~Entity]
        Returns -> MetricResults
        """
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise TypeError(
                f'Expected entities to be a Sequence, received: {type(entities)}'
            )

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'MetricsDebug',
            'request': 'GetMetrics',
            'version': 2,
            'params': _params,
        }
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return MetricResults.from_json(reply['response'])

    async def SetMeterStatus(self, statues=None) -> ErrorResults:
        """
        SetMeterStatus sets meter statuses for entities.

        statues : typing.Sequence[~MeterStatusParam]
        Returns -> ErrorResults
        """
        if statues is not None and not isinstance(statues, (bytes, str, list)):
            raise TypeError(
                f'Expected statues to be a Sequence, received: {type(statues)}'
            )

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'MetricsDebug',
            'request': 'SetMeterStatus',
            'version': 2,
            'params': _params,
        }
        _params['statues'] = statues
        reply = await self.rpc(msg)
        return ErrorResults.from_json(reply['response'])


class SecretsFacade(Type):
    name = 'Secrets'
    version = 2
    schema = {
        'definitions': {
            'CreateSecretArg': {
                'additionalProperties': False,
                'properties': {
                    'UpsertSecretArg': {'$ref': '#/definitions/UpsertSecretArg'},
                    'content': {'$ref': '#/definitions/SecretContentParams'},
                    'description': {'type': 'string'},
                    'expire-time': {'format': 'date-time', 'type': 'string'},
                    'label': {'type': 'string'},
                    'owner-tag': {'type': 'string'},
                    'params': {
                        'patternProperties': {
                            '.*': {'additionalProperties': True, 'type': 'object'}
                        },
                        'type': 'object',
                    },
                    'rotate-policy': {'type': 'string'},
                    'uri': {'type': 'string'},
                },
                'required': ['UpsertSecretArg', 'owner-tag'],
                'type': 'object',
            },
            'CreateSecretArgs': {
                'additionalProperties': False,
                'properties': {
                    'args': {
                        'items': {'$ref': '#/definitions/CreateSecretArg'},
                        'type': 'array',
                    }
                },
                'required': ['args'],
                'type': 'object',
            },
            'DeleteSecretArg': {
                'additionalProperties': False,
                'properties': {
                    'label': {'type': 'string'},
                    'revisions': {'items': {'type': 'integer'}, 'type': 'array'},
                    'uri': {'type': 'string'},
                },
                'required': ['uri', 'label'],
                'type': 'object',
            },
            'DeleteSecretArgs': {
                'additionalProperties': False,
                'properties': {
                    'args': {
                        'items': {'$ref': '#/definitions/DeleteSecretArg'},
                        'type': 'array',
                    }
                },
                'required': ['args'],
                'type': 'object',
            },
            'Error': {
                'additionalProperties': False,
                'properties': {
                    'code': {'type': 'string'},
                    'info': {
                        'patternProperties': {
                            '.*': {'additionalProperties': True, 'type': 'object'}
                        },
                        'type': 'object',
                    },
                    'message': {'type': 'string'},
                },
                'required': ['message', 'code'],
                'type': 'object',
            },
            'ErrorResult': {
                'additionalProperties': False,
                'properties': {'error': {'$ref': '#/definitions/Error'}},
                'type': 'object',
            },
            'ErrorResults': {
                'additionalProperties': False,
                'properties': {
                    'results': {
                        'items': {'$ref': '#/definitions/ErrorResult'},
                        'type': 'array',
                    }
                },
                'required': ['results'],
                'type': 'object',
            },
            'GrantRevokeUserSecretArg': {
                'additionalProperties': False,
                'properties': {
                    'applications': {'items': {'type': 'string'}, 'type': 'array'},
                    'label': {'type': 'string'},
                    'uri': {'type': 'string'},
                },
                'required': ['uri', 'label', 'applications'],
                'type': 'object',
            },
            'ListSecretResult': {
                'additionalProperties': False,
                'properties': {
                    'create-time': {'format': 'date-time', 'type': 'string'},
                    'description': {'type': 'string'},
                    'label': {'type': 'string'},
                    'latest-expire-time': {'format': 'date-time', 'type': 'string'},
                    'latest-revision': {'type': 'integer'},
                    'next-rotate-time': {'format': 'date-time', 'type': 'string'},
                    'owner-tag': {'type': 'string'},
                    'revisions': {
                        'items': {'$ref': '#/definitions/SecretRevision'},
                        'type': 'array',
                    },
                    'rotate-policy': {'type': 'string'},
                    'update-time': {'format': 'date-time', 'type': 'string'},
                    'uri': {'type': 'string'},
                    'value': {'$ref': '#/definitions/SecretValueResult'},
                    'version': {'type': 'integer'},
                },
                'required': [
                    'uri',
                    'version',
                    'owner-tag',
                    'latest-revision',
                    'create-time',
                    'update-time',
                    'revisions',
                ],
                'type': 'object',
            },
            'ListSecretResults': {
                'additionalProperties': False,
                'properties': {
                    'results': {
                        'items': {'$ref': '#/definitions/ListSecretResult'},
                        'type': 'array',
                    }
                },
                'required': ['results'],
                'type': 'object',
            },
            'ListSecretsArgs': {
                'additionalProperties': False,
                'properties': {
                    'filter': {'$ref': '#/definitions/SecretsFilter'},
                    'show-secrets': {'type': 'boolean'},
                },
                'required': ['show-secrets', 'filter'],
                'type': 'object',
            },
            'SecretContentParams': {
                'additionalProperties': False,
                'properties': {
                    'data': {
                        'patternProperties': {'.*': {'type': 'string'}},
                        'type': 'object',
                    },
                    'value-ref': {'$ref': '#/definitions/SecretValueRef'},
                },
                'type': 'object',
            },
            'SecretRevision': {
                'additionalProperties': False,
                'properties': {
                    'backend-name': {'type': 'string'},
                    'create-time': {'format': 'date-time', 'type': 'string'},
                    'expire-time': {'format': 'date-time', 'type': 'string'},
                    'revision': {'type': 'integer'},
                    'update-time': {'format': 'date-time', 'type': 'string'},
                    'value-ref': {'$ref': '#/definitions/SecretValueRef'},
                },
                'required': ['revision'],
                'type': 'object',
            },
            'SecretValueRef': {
                'additionalProperties': False,
                'properties': {
                    'backend-id': {'type': 'string'},
                    'revision-id': {'type': 'string'},
                },
                'required': ['backend-id', 'revision-id'],
                'type': 'object',
            },
            'SecretValueResult': {
                'additionalProperties': False,
                'properties': {
                    'data': {
                        'patternProperties': {'.*': {'type': 'string'}},
                        'type': 'object',
                    },
                    'error': {'$ref': '#/definitions/Error'},
                },
                'type': 'object',
            },
            'SecretsFilter': {
                'additionalProperties': False,
                'properties': {
                    'label': {'type': 'string'},
                    'owner-tag': {'type': 'string'},
                    'revision': {'type': 'integer'},
                    'uri': {'type': 'string'},
                },
                'type': 'object',
            },
            'StringResult': {
                'additionalProperties': False,
                'properties': {
                    'error': {'$ref': '#/definitions/Error'},
                    'result': {'type': 'string'},
                },
                'required': ['result'],
                'type': 'object',
            },
            'StringResults': {
                'additionalProperties': False,
                'properties': {
                    'results': {
                        'items': {'$ref': '#/definitions/StringResult'},
                        'type': 'array',
                    }
                },
                'required': ['results'],
                'type': 'object',
            },
            'UpdateUserSecretArg': {
                'additionalProperties': False,
                'properties': {
                    'UpsertSecretArg': {'$ref': '#/definitions/UpsertSecretArg'},
                    'auto-prune': {'type': 'boolean'},
                    'content': {'$ref': '#/definitions/SecretContentParams'},
                    'description': {'type': 'string'},
                    'existing-label': {'type': 'string'},
                    'expire-time': {'format': 'date-time', 'type': 'string'},
                    'label': {'type': 'string'},
                    'params': {
                        'patternProperties': {
                            '.*': {'additionalProperties': True, 'type': 'object'}
                        },
                        'type': 'object',
                    },
                    'rotate-policy': {'type': 'string'},
                    'uri': {'type': 'string'},
                },
                'required': ['UpsertSecretArg', 'uri', 'existing-label'],
                'type': 'object',
            },
            'UpdateUserSecretArgs': {
                'additionalProperties': False,
                'properties': {
                    'args': {
                        'items': {'$ref': '#/definitions/UpdateUserSecretArg'},
                        'type': 'array',
                    }
                },
                'required': ['args'],
                'type': 'object',
            },
            'UpsertSecretArg': {
                'additionalProperties': False,
                'properties': {
                    'content': {'$ref': '#/definitions/SecretContentParams'},
                    'description': {'type': 'string'},
                    'expire-time': {'format': 'date-time', 'type': 'string'},
                    'label': {'type': 'string'},
                    'params': {
                        'patternProperties': {
                            '.*': {'additionalProperties': True, 'type': 'object'}
                        },
                        'type': 'object',
                    },
                    'rotate-policy': {'type': 'string'},
                },
                'type': 'object',
            },
        },
        'properties': {
            'CreateSecrets': {
                'description': 'CreateSecrets creates new ' 'secrets.',
                'properties': {
                    'Params': {'$ref': '#/definitions/CreateSecretArgs'},
                    'Result': {'$ref': '#/definitions/StringResults'},
                },
                'type': 'object',
            },
            'GrantSecret': {
                'description': 'GrantSecret grants access to a ' 'user secret.',
                'properties': {
                    'Params': {'$ref': '#/definitions/GrantRevokeUserSecretArg'},
                    'Result': {'$ref': '#/definitions/ErrorResults'},
                },
                'type': 'object',
            },
            'ListSecrets': {
                'description': 'ListSecrets lists available ' 'secrets.',
                'properties': {
                    'Params': {'$ref': '#/definitions/ListSecretsArgs'},
                    'Result': {'$ref': '#/definitions/ListSecretResults'},
                },
                'type': 'object',
            },
            'RemoveSecrets': {
                'description': 'RemoveSecrets remove user ' 'secret.',
                'properties': {
                    'Params': {'$ref': '#/definitions/DeleteSecretArgs'},
                    'Result': {'$ref': '#/definitions/ErrorResults'},
                },
                'type': 'object',
            },
            'RevokeSecret': {
                'description': 'RevokeSecret revokes access ' 'to a user secret.',
                'properties': {
                    'Params': {'$ref': '#/definitions/GrantRevokeUserSecretArg'},
                    'Result': {'$ref': '#/definitions/ErrorResults'},
                },
                'type': 'object',
            },
            'UpdateSecrets': {
                'description': 'UpdateSecrets creates new ' 'secrets.',
                'properties': {
                    'Params': {'$ref': '#/definitions/UpdateUserSecretArgs'},
                    'Result': {'$ref': '#/definitions/ErrorResults'},
                },
                'type': 'object',
            },
        },
        'type': 'object',
    }

    async def CreateSecrets(self, args=None) -> StringResults:
        """
        CreateSecrets creates new secrets.

        args : typing.Sequence[~CreateSecretArg]
        Returns -> StringResults
        """
        if args is not None and not isinstance(args, (bytes, str, list)):
            raise TypeError(f'Expected args to be a Sequence, received: {type(args)}')

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'Secrets',
            'request': 'CreateSecrets',
            'version': 2,
            'params': _params,
        }
        _params['args'] = args
        reply = await self.rpc(msg)
        return StringResults.from_json(reply['response'])

    async def GrantSecret(
        self, applications=None, label=None, uri=None
    ) -> ErrorResults:
        """
        GrantSecret grants access to a user secret.

        applications : typing.Sequence[str]
        label : str
        uri : str
        Returns -> ErrorResults
        """
        if applications is not None and not isinstance(
            applications, (bytes, str, list)
        ):
            raise TypeError(
                f'Expected applications to be a Sequence, received: {type(applications)}'
            )

        if label is not None and not isinstance(label, (bytes, str)):
            raise TypeError(f'Expected label to be a str, received: {type(label)}')

        if uri is not None and not isinstance(uri, (bytes, str)):
            raise TypeError(f'Expected uri to be a str, received: {type(uri)}')

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'Secrets',
            'request': 'GrantSecret',
            'version': 2,
            'params': _params,
        }
        _params['applications'] = applications
        _params['label'] = label
        _params['uri'] = uri
        reply = await self.rpc(msg)
        return ErrorResults.from_json(reply['response'])

    async def ListSecrets(self, filter_=None, show_secrets=None) -> ListSecretResults:
        """
        ListSecrets lists available secrets.

        filter_ : SecretsFilter
        show_secrets : bool
        Returns -> ListSecretResults
        """
        if filter_ is not None and not isinstance(filter_, (dict, SecretsFilter)):
            raise TypeError(
                f'Expected filter_ to be a SecretsFilter, received: {type(filter_)}'
            )

        if show_secrets is not None and not isinstance(show_secrets, bool):
            raise TypeError(
                f'Expected show_secrets to be a bool, received: {type(show_secrets)}'
            )

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'Secrets',
            'request': 'ListSecrets',
            'version': 2,
            'params': _params,
        }
        _params['filter'] = filter_
        _params['show-secrets'] = show_secrets
        reply = await self.rpc(msg)
        return ListSecretResults.from_json(reply['response'])

    async def RemoveSecrets(self, args=None) -> ErrorResults:
        """
        RemoveSecrets remove user secret.

        args : typing.Sequence[~DeleteSecretArg]
        Returns -> ErrorResults
        """
        if args is not None and not isinstance(args, (bytes, str, list)):
            raise TypeError(f'Expected args to be a Sequence, received: {type(args)}')

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'Secrets',
            'request': 'RemoveSecrets',
            'version': 2,
            'params': _params,
        }
        _params['args'] = args
        reply = await self.rpc(msg)
        return ErrorResults.from_json(reply['response'])

    async def RevokeSecret(
        self, applications=None, label=None, uri=None
    ) -> ErrorResults:
        """
        RevokeSecret revokes access to a user secret.

        applications : typing.Sequence[str]
        label : str
        uri : str
        Returns -> ErrorResults
        """
        if applications is not None and not isinstance(
            applications, (bytes, str, list)
        ):
            raise TypeError(
                f'Expected applications to be a Sequence, received: {type(applications)}'
            )

        if label is not None and not isinstance(label, (bytes, str)):
            raise TypeError(f'Expected label to be a str, received: {type(label)}')

        if uri is not None and not isinstance(uri, (bytes, str)):
            raise TypeError(f'Expected uri to be a str, received: {type(uri)}')

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'Secrets',
            'request': 'RevokeSecret',
            'version': 2,
            'params': _params,
        }
        _params['applications'] = applications
        _params['label'] = label
        _params['uri'] = uri
        reply = await self.rpc(msg)
        return ErrorResults.from_json(reply['response'])

    async def UpdateSecrets(self, args=None) -> ErrorResults:
        """
        UpdateSecrets creates new secrets.

        args : typing.Sequence[~UpdateUserSecretArg]
        Returns -> ErrorResults
        """
        if args is not None and not isinstance(args, (bytes, str, list)):
            raise TypeError(f'Expected args to be a Sequence, received: {type(args)}')

        # map input types to rpc msg
        _params = {}
        msg = {
            'type': 'Secrets',
            'request': 'UpdateSecrets',
            'version': 2,
            'params': _params,
        }
        _params['args'] = args
        reply = await self.rpc(msg)
        return ErrorResults.from_json(reply['response'])
