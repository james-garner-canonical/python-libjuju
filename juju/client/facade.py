# Copyright 2023 Canonical Ltd.
# Licensed under the Apache V2, see LICENCE file for details.

from __future__ import annotations
import argparse
import builtins
import dataclasses
import json
import keyword
import pprint
import re
import textwrap
import typing
from glob import glob
from pathlib import Path
from typing import (
    Any,
    Dict,
    Iterable,
    List,
    Protocol,
    Set,
    Tuple,
    TypeVar,
)

import packaging.version
from typing_extensions import NotRequired


_marker = object()

JUJU_VERSION = re.compile(r'[0-9]+\.[0-9-]+[\.\-][0-9a-z]+(\.[0-9]+)?')

# Map basic types to Python's typing with a callable
SCHEMA_TO_PYTHON: Dict[str, type] = {
    'string': str,
    'integer': int,
    'float': float,
    'number': float,
    'boolean': bool,
    'object': Any,  # type: ignore
}


# Friendly warning message to stick at the top of generated files.
HEADER = """\
# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

"""


# Classes and helper functions that we'll write to _client.py
LOOKUP_FACADE = '''
def lookup_facade(name: str, version: int) -> typing.Type[juju.client.facade.Type]:
    """Return the facade object of the given version or lower."""
    for v in range(version, 0, -1):
        try:
            client_module = CLIENTS[str(v)]
            facade = getattr(client_module, name)
            return facade
        except (KeyError, AttributeError):
            continue
    raise ImportError(f'No supported version for facade: {name}')

'''

TYPE_FACTORY = '''
class TypeFactory:
    @classmethod
    def from_connection(
        cls, connection: juju.client.connection.Connection
    ) -> juju.client.facade.Type:
        """Return a facade object initialised with the connection.

        Given a connected Connection object, return an initialized and
        connected instance of an API Interface matching the name of
        this class.

        @param connection: initialized Connection object.
        """
        class_name = cls.__name__
        if not class_name.endswith('Facade'):
            raise TypeError(f'Unexpected class name: {class_name}')
        facade_name = class_name[: -len('Facade')]

        version = connection.facades.get(facade_name)
        if version is None:
            raise ValueError(f'No facade {facade_name} in facades {connection.facades}')

        FacadeClass = lookup_facade(cls.__name__, version)
        facade = FacadeClass()
        facade.connect(connection)
        return facade

    @classmethod
    def best_facade_version(
        cls, connection: juju.client.connection.Connection
    ) -> typing.Optional[int]:
        """
        Returns the best facade version for a given facade. This will help with
        trying to provide different functionality for different facade versions.

        @param connection: initialized Connection object.
        """
        facade_name = cls.__name__
        if not facade_name.endswith('Facade'):
            raise TypeError(f'Unexpected class name: {facade_name}')
        facade_name = facade_name[: -len('Facade')]
        return connection.facades.get(facade_name)


'''


JSONObject = Dict[str, 'JSONData']
JSONData = typing.Union[
    'JSONObject',
    List['JSONData'],
    str,
    int,
    float,
    bool,
    None,
]


class Options(Protocol):
    schema: str
    output_dir: str


def booler(v):
    if isinstance(v, str):
        if v == "false":
            return False
    return bool(v)


basic_types = [str, bool, int, float]


type_mapping = {
    'str': '(bytes, str)',
    'Sequence': '(bytes, str, list)',
    'Union': 'dict',
    'Mapping': 'dict',
}


def name_to_py(name: str) -> str:
    result = name.replace("-", "_")
    result = result.lower()
    if keyword.iskeyword(result) or result in dir(builtins):
        result += "_"
    return result


def var_type_to_py(kind):
    return 'None'


def strcast(kind):
    if kind in basic_types or type(kind) in basic_types:
        return kind.__name__
    if str(kind).startswith('~'):
        return str(kind)[1:]
    if kind is typing.Any:
        return 'Any'
    try:
        if issubclass(kind, typing.GenericMeta):
            return str(kind)[1:]
    except AttributeError:
        pass
    return kind


def buildValidation(name, instance_type, instance_sub_type, ident=None) -> str:
    if ident is None:
        ident = '    '
    return (
        f"{ident}if {name} is not None and not isinstance({name}, {instance_sub_type}):\n"
        f"{ident}    raise TypeError(f'Expected {name} to be a {instance_type}, received: {{type({name})}}')\n"
    )


def get_definitions(schema: Schema) -> Dict[str, List[str]]:
    definitions: Dict[str, List[str]] = {}
    INDENT = "    "
    for name in sorted(schema.definitions):
        if not name:
            # when running on juju 3.1.0 client-only schemas, we get a seemingly empty entry with no name
            # this breaks codegen when generating a class with no name so we explicitly skip it here
            # note that this is not a problem with the original 3.1.0 full schema (client + others)
            # nor is it a problem with client-only schemas for latter juju versions (e.g. 3.3.0)
            continue
        if name == 'FacadeVersions':
            # not part of the api that we expose to users
            continue
        name = get_reference_name(name)
        params = schema.registry[name]
        lines: typing.List[str] = [
            f'class {name}(Type):',
            f'    _toSchema = {pprint.pformat({param.to_arg_name(): param.name for param in params}, width=999)}',
            f'    _toPy = {pprint.pformat({param.name: param.to_arg_name() for param in params}, width=999)}',
            f'',
            f'    def __init__(self{", " if params else ""}{", ".join(f"{param.to_arg_name()}=None" for param in params)}, **unknown_fields):',
            f'        """',
            *(f'        {param.to_arg_name()} : {param.to_annotation(nodiff=True)}' for param in params),
            f'        """',
        ]
        if params:
            for param in params:
                lines.append(param.to_alias_assignment(indent_level=2))
            lines.append('')
            lines.append(f'{INDENT * 2}# Validate arguments against known Juju API types.')
            for param in params:
                validation = param.to_validation(indent_level=2, alias=True)
                if validation is not None:
                    lines.append(validation)
            for param in params:
                lines.append(f'{INDENT * 2}self.{param.to_arg_name()} = {param.to_arg_name(alias=True)}')
        lines.append(f'{INDENT * 2}self.unknown_fields = unknown_fields')
        lines.append('')
        lines.append('')
        definitions[name] = lines
        schema.validate(lines)
    return definitions


def makeFunc(
    schema: Schema,
    name: str,
    description: str,
    result,
    params_name: str | None,
    _async: bool = True,
):
    INDENT = "    "
    if params_name is not None:
        params = schema.registry[get_reference_name(params_name)]
    else:
        params = []
    assignments = [
        f"{INDENT}_params['{param.name}'] = {name_to_py(param.name)}"
        for param in params
    ]
    res = strcast(result) if result else None
    doc_string = (description + '\n\n' if description else '') + '\n'.join(
        f'{name_to_py(param.name)} : {param.to_annotation(nodiff=True)}'
        for param in params
    )
    lines = [
        f'',
        f'',
        (
            f'{"async " if _async else ""}'
            f'def {name}(self{", " if params else ""}{", ".join(f"{name_to_py(param.name)}=None" for param in params)})'
            f' -> {result.__name__ if result is not None else "JSONObject"}:'
        ),
        f'    """',
        textwrap.indent(doc_string, INDENT),
        f'    Returns -> {res}',
        f'    """',
        '\n'.join(s for s in (param.to_validation(indent_level=1) for param in params) if s is not None),
        f'    # map input types to rpc msg',
        f'    _params = {{}}',
        f'    msg = {{',
        f"        'type': '{schema.name}',",
        f"        'request': '{name}',",
        f"        'version': {schema.version},",
        f"        'params': _params,",
        f'    }}',
        '\n'.join(assignments),
        f'    reply = {"await " if _async else ""}self.rpc(msg)',
        (
            f"    return {result.__name__}.from_json(reply['response'])"
            if result is not None
            else f'    return reply'
        ),
        f'',
    ]
    fsource = '\n'.join(lines)
    namespace = get_namespace(schema)
    exec(fsource, namespace)
    func = namespace[name]
    return func, fsource


RPCFunc = typing.Callable[[JSONObject], typing.Awaitable[JSONObject]]

def makeRPCFunc(schema: Schema) -> Tuple[RPCFunc, str]:
    source = """

async def rpc(self, msg):
    '''
    Patch rpc method to add Id.
    '''
    if not hasattr(self, 'Id'):
        raise RuntimeError('Missing "Id" field')
    msg['Id'] = id

    from .facade import TypeEncoder
    reply = await self.connection.rpc(msg, encoder=TypeEncoder)
    return reply

"""
    namespace = get_namespace(schema)
    exec(source, namespace)
    func = namespace["rpc"]
    return func, source


def _buildMethod(schema: Schema, name: str):
    result = None
    method = schema.properties[name]
    description = ""
    params_name = None
    if 'description' in method:
        description = method['description']
    if 'properties' in method:
        prop = method['properties']
        spec = prop.get('Params')
        if spec:
            params_name = spec['$ref']
        spec = prop.get('Result')
        if spec:
            if '$ref' in spec:
                result = get_type(spec['$ref'])
            else:
                result = SCHEMA_TO_PYTHON[spec['type']]
    return makeFunc(
        schema=schema,
        name=name,
        description=description,
        result=result,
        params_name=params_name,
    )


def buildFacade(schema: Schema) -> typing.Tuple[typing.Type[Type], str]:
    cls = type(
        schema.name,
        (Type,),
        {'name': schema.name, 'version': schema.version, 'schema': schema},
    )
    schema_text = textwrap.indent(pprint.pformat(schema.schema), "    ")
    source = (
        f'class {schema.name}Facade(Type):\n'
        f'    name = {schema.name!r}\n'
        f'    version = {schema.version}\n'
        f'    schema = {schema_text}\n'
    )
    return cls, source


class TypeEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, Type):
            return obj.serialize()
        return json.JSONEncoder.default(self, obj)


C = TypeVar("C")

class Type:
    def connect(self, connection):
        self.connection = connection

    def __repr__(self):
        return f'{self.__class__}({self.__dict__})'

    def __eq__(self, other):
        if not isinstance(other, Type):
            return NotImplemented

        return self.__dict__ == other.__dict__

    async def rpc(self, msg: JSONObject) -> JSONObject:
        result = await self.connection.rpc(msg, encoder=TypeEncoder)
        return result

    @classmethod
    def from_json(cls: typing.Type[C], data: typing.Union[JSONData, C]) -> typing.Optional[C]:
        def _parse_nested_list_entry(expr, result_dict):
            if isinstance(expr, str):
                if '>' in expr or '>=' in expr:
                    # something like juju >= 2.9.31
                    i = expr.index('>')
                    _key = expr[:i].strip()
                    _value = expr[i:].strip()
                    result_dict[_key] = _value
                else:
                    # this is a simple entry
                    result_dict[expr] = ''
            elif isinstance(expr, dict):
                for _, v in expr.items():
                    _parse_nested_list_entry(v, result_dict)
            elif isinstance(expr, list):
                for v in expr:
                    _parse_nested_list_entry(v, result_dict)
            else:
                raise TypeError(f"Unexpected type of entry in assumes expression: {expr}")

        if isinstance(data, cls):
            return data
        if isinstance(data, str):
            try:
                data = json.loads(data)
            except json.JSONDecodeError:
                raise
        if isinstance(data, dict):
            d = {}
            for k, v in (data or {}).items():
                d[cls._toPy.get(k, k)] = v
            try:
                return cls(**d)
            except TypeError:
                raise
        if isinstance(data, list):
            # check: https://juju.is/docs/sdk/assumes
            # assumes are in the form of a list
            d = {}
            _parse_nested_list_entry(data, d)
            return cls(**d)
        return None

    def serialize(self):
        d = {}
        for attr, tgt in self._toSchema.items():
            d[tgt] = getattr(self, attr)
        return d

    def to_json(self):
        return json.dumps(self.serialize(), cls=TypeEncoder, sort_keys=True)

    # treat subscript gets as JSON representation
    def __getitem__(self, key):
        attr = self._toPy[key]
        return getattr(self, attr)

    # treat subscript sets as JSON representation
    def __setitem__(self, key, value):
        attr = self._toPy[key]
        setattr(self, attr, value)

    # legacy: generated definitions used to not correctly
    # create typed objects and would use dict instead (from JSON)
    # so we emulate some dict methods.
    def get(self, key, default=None):
        try:
            attr = self._toPy[key]
        except KeyError:
            return default
        return getattr(self, attr, default)


Struct = List[Tuple[str, Any]]


class RawDict(typing.TypedDict):
    Name: str
    Version: int
    Schema: SchemaDict


class SchemaDict(typing.TypedDict):
    type: JSONObject
    properties: Dict[str, JSONObject]
    definitions: NotRequired[Dict[str, JSONObject]]


class Schema:
    def __init__(self, raw: RawDict):
        self.name: str = raw['Name']
        self.version: int = raw['Version']
        self.schema: SchemaDict = raw['Schema']
        self.properties: Dict[str, JSONObject] = self.schema['properties']
        self.definitions: Dict[str, JSONObject] = self.schema.get('definitions', {})
        self.registry: Dict[str, List[Param]] = {
            get_reference_name(name): Param.list_from_definition(get_reference_name(name), definition)
            for name, definition in self.definitions.items()
        }

    def validate(self, lines: list[str]) -> None:
        """Compile and execute generated lines of code in schema namespace."""
        try:
            co = compile('\n'.join(lines), __name__, 'exec')
            namespace = get_namespace(self)
            exec(co, namespace)
        except Exception:
            print('\n'.join(lines))
            raise


class DefinitionDict(typing.TypedDict):
    properties: NotRequired[Dict[str, PropertyDict]]
    patternProperties: NotRequired[PatternPropertyDict]
    additionalProperties: NotRequired[Any]


PropertyDict = typing.TypedDict(
    'PropertyDict',
    {
        '$ref': NotRequired[str],
        'type': typing.Literal['array', 'object', 'string', 'integer', 'float', 'number', 'boolean', 'object'],
    }
)


PatternPropertyDict = typing.TypedDict('PatternPropertyDict', {'.*': PropertyDict})


@dataclasses.dataclass
class Param:
    name: str
    kind: typing.Literal['basic', 'ref', 'untyped']
    data: Any
    array: bool = False
    mapping: bool = False

    @classmethod
    def list_from_definition(cls, definition_name: str, definition: DefinitionDict) -> list[Param]:
        params: list[Param] = []
        for property_name, property in sorted(definition.get('properties', {}).items()):
            if '$ref' in property:
                params.append(Param(name=property_name, kind='ref', data=get_reference_name(property['$ref'])))
                continue
            if property['type'] == 'array':
                params.append(cls.array_param(name=property_name, property=property))
            elif property['type'] == 'object':
                params.extend(
                    cls.list_from_definition(
                        definition_name=property_name,
                        definition=typing.cast(DefinitionDict, property),
                    )
                )
            else:
                params.append(Param(name=property_name, kind='basic', data=property['type']))

        pattern_properties = definition.get('patternProperties')
        if pattern_properties:
            if '.*' not in pattern_properties:
                raise ValueError(f'Cannot handle actual pattern in patternProperties {pattern_properties}')
            pattern_property = pattern_properties['.*']
            if '$ref' in pattern_property:
                params.append(Param(name=definition_name, kind='ref', data=get_reference_name(pattern_property['$ref']), mapping=True))
            elif pattern_property['type'] == 'array':
                params.append(cls.array_param(name=definition_name, property=pattern_property, mapping=True))
            else:
                params.append(Param(name=definition_name, kind='basic', data=pattern_property['type'], mapping=True))

        if not params and 'additionalProperties' in definition and definition['additionalProperties']:
            params.append(Param(name=definition_name, kind='untyped', data=None))

        return params

    @classmethod
    def array_param(cls, name: str, property: PropertyDict, mapping: bool = False) -> Param:
        if "$ref" in property:
            return Param(name=name, kind='ref', data=get_reference_name(property['$ref']), array=True, mapping=mapping)
        kind = property.get("type")
        if kind and kind == "array":
            items = property['items']
            return cls.array_param(name=name, property=items, mapping=mapping)
        return Param(name=name, kind='basic', data=property['type'], array=True, mapping=mapping)

    def to_arg_name(self, alias: bool = False) -> str:
        return name_to_py(self.name) + ("_" if alias else "")

    def to_annotation(self, nodiff: bool = False) -> str:
        template = '{}'
        if self.mapping:
            template = template.format('typing.Mapping[str, {}]')
        if self.array:
            template = template.format('typing.Sequence[{}]')
        if self.kind == 'basic':
            kind = SCHEMA_TO_PYTHON[self.data].__name__
            if nodiff and len(template) > 2 and kind == 'Any':
                # match previous generated code exactly -- typing.Any when inside Sequence etc
                kind = 'typing.Any'
            template = template.format(kind)
        elif self.kind == 'ref':
            prefix = "~" if nodiff and len(template) > 2 else ""
            # match previous generated code exactly -- prefix with ~ when inside Sequence etc
            template = template.format(f'{prefix}{self.data}')
        else:
            template = template.format('Any')
        return template

    def to_unparametrized_annotation(self) -> str | None:
        if self.mapping:
            return 'Mapping'
        if self.array:
            return 'Sequence'
        if self.kind == 'basic':
            return SCHEMA_TO_PYTHON[self.data].__name__
        if self.kind == 'ref':
            return self.data
        if self.kind == 'untyped':
            return None
        raise ValueError()

    def to_types(self) -> str | None:
        if self.mapping:
            return 'dict'
        if self.array:
            return '(bytes, str, list)'
        if self.kind == 'basic':
            if self.data == 'string':
                return '(bytes, str)'
            return SCHEMA_TO_PYTHON[self.data].__name__
        if self.kind == 'ref':
            return f'(dict, {self.data})'
        if self.kind == 'untyped':
            return None
        raise ValueError()

    def to_alias_assignment(self, indent_level: int = 0) -> str:
        indent = " " * 4 * indent_level
        return f'{indent}{self.to_arg_name(alias=True)} = {self.to_arg_evaluation()}'

    def to_arg_evaluation(self) -> str:
        if self.kind != 'ref':
            return self.to_arg_name()
        if self.array:
            return (
                f'['
                f'{self.data}.from_json(o) '
                f'for o in {self.to_arg_name()} or []'
                f']'
            )
        if self.mapping:
            assert not self.array  # unhandled case of both
            return (
                f'{{'
                f'k: {self.data}.from_json(v) '
                f'for k, v in ({self.to_arg_name()} or {{}}).items()'
                f'}}'
            )
        return (
            f'{self.data}.from_json({self.to_arg_name()}) '
            f'if {self.to_arg_name()} else None'
        )

    def to_validation(self, indent_level: int = 0, alias: bool = False) -> str | None:
        indent = " " * 4 * indent_level
        types = self.to_types()
        if types is not None:
            return buildValidation(
                self.to_arg_name(alias=alias),
                self.to_unparametrized_annotation(),
                types,
                ident=indent,
            )


def get_type(name: str) -> TypeVar:
    return TypeVar(get_reference_name(name))


def get_reference_name(ref: str) -> str:
    if ref.startswith("#/definitions/"):
        _, _, ref = ref.rpartition("/")
    return ref


def get_namespace(schema: Schema) -> Dict[str, Any]:
    return {
        'Type': Type,
        'typing': typing,
        **schema.registry,
    }


def write_facades(captures: Dict[int, Dict[str, List[str]]], options: Options) -> None:
    """
    Write the Facades to the appropriate _client<version>.py

    """
    for version in sorted(captures):
        with open(f'{options.output_dir}/_client{version}.py', 'w') as f:
            f.write(HEADER)
            f.write('from juju.client.facade import Type, JSONObject\n')
            f.write('from juju.client._definitions import *\n')
            f.write('\n')
            for key in sorted(captures[version]):
                f.write('\n'.join(captures[version][key]))
                f.write('\n')

    # Return the last (most recent) version for use in other routines.
    return version


def write_definitions(captures: Dict[str, List[str]], options: Options) -> None:
    """
    Write auxillary (non versioned) classes to
    _definitions.py The auxillary classes currently get
    written redudantly into each capture object, so we can look in
    one of them -- we just use the last one from the loop above.

    """
    with open(f'{options.output_dir}/_definitions.py', 'w') as f:
        f.write(HEADER)
        f.write("from juju.client.facade import Type\n\n")
        for key in sorted(captures):
            f.write('\n'.join(captures[key]))


def write_client(
    captures: Dict[int, Dict[str, List[str]]],
    factories: Iterable[str],
    options: Options,
) -> None:
    """
    Write the TypeFactory classes to _client.py, along with some
    imports and tables so that we can look up versioned Facades.
    """
    with open(f'{options.output_dir}/_client.py', 'w') as f:
        f.write(HEADER)
        f.write('from __future__ import annotations\n')
        f.write('import typing\n')
        f.write('\n')
        f.write("from juju.client._definitions import *\n")
        f.write('from juju.client import (\n')
        for version in sorted(captures):
            f.write(f'    _client{version},\n')
        f.write(')\n')
        f.write('\n')
        f.write('if typing.TYPE_CHECKING:\n')
        f.write('    import juju.client.connection\n')
        f.write('    import juju.client.facade\n')
        f.write('\n')
        f.write('\n')
        f.write('CLIENTS = {\n')
        for version in sorted(captures):
            f.write(f"    '{version}': _client{version},\n")
        f.write('}\n')
        f.write('\n')
        f.write(LOOKUP_FACADE)  # TODO: inline?
        f.write(TYPE_FACTORY)  # TODO: inline?
        for name in sorted(factories):
            f.write(f'class {name}(TypeFactory):\n    pass\n\n\n')


def generate_definitions(schemas: Dict[str, List[Schema]]) -> Dict[str, List[str]]:
    definitions: Dict[str, List[str]] = {}
    for juju_version in sorted(schemas):  # newer definitions overwrite older
        for schema in schemas[juju_version]:
            for name, lines in get_definitions(schema).items():
                definitions[name] = lines
    return definitions


def generate_factories(schemas: Dict[str, List[Schema]]) -> Set[str]:
    factories: Set[str] = set()
    for list_of_schemas in schemas.values():
        for schema in list_of_schemas:
            factories.add(f'{schema.name}Facade')
            factories.update(
                get_reference_name(name)
                for name in schema.definitions
                if 'Facade' in name
            )
    return factories


def generate_facades(schemas: Dict[str, List[Schema]]) -> Dict[int, Dict[str, List[str]]]:
    captures: Dict[int, Dict[str, List[str]]] = {}
    # Build the Facade classes
    for juju_version in sorted(schemas.keys(), key=packaging.version.parse):
        for schema in schemas[juju_version]:
            cls, source = buildFacade(schema)
            cls_name = f'{schema.name}Facade'
            capture = captures.setdefault(schema.version, {})
            capture[cls_name] = [source]

            # Build the methods for each Facade class.
            for methodname in sorted(schema.properties):
                method, source = _buildMethod(schema, methodname)
                setattr(cls, methodname, method)
                capture[cls_name].append(textwrap.indent(source, prefix='    '))

            # Build the override RPC method if the Facade is a watcher.
            if "Next" in schema.properties and "Stop" in schema.properties:
                method, source = makeRPCFunc(schema)
                setattr(cls, "rpc", method)
                capture[cls_name].append(textwrap.indent(source, prefix='    '))

    return captures


def load_schemas(options: Options) -> Dict[str, List[Schema]]:
    schemas: Dict[str, List[Schema]] = {}
    for path in sorted(glob(options.schema)):
        match = re.search(JUJU_VERSION, path)
        if match is None:
            print(f'Cannot extract a juju version from {path}')
            print('Schemas must include a juju version in the filename')
            raise SystemExit(1)
        juju_version = match.group()
        new_schemas = json.loads(Path(path).read_text("utf-8"))
        schemas[juju_version] = [Schema(s) for s in new_schemas]
    return schemas


def setup() -> Options:
    parser = argparse.ArgumentParser()
    parser.add_argument("-s", "--schema", default="juju/client/schemas-juju-*.json")
    parser.add_argument("-o", "--output_dir", default="juju/client")
    options = parser.parse_args()
    return options


def main() -> None:
    options = setup()
    schemas = load_schemas(options)
    # definitions
    definitions = generate_definitions(schemas)
    # juju/client/_definitions.py
    write_definitions(definitions, options)
    # facades and factories
    captures = generate_facades(schemas)
    factories = generate_factories(schemas)
    # juju/client/_client.py
    write_client(captures=captures, factories=factories, options=options)
    # juju/client/_client{N}.py
    write_facades(captures, options)


if __name__ == '__main__':
    main()
